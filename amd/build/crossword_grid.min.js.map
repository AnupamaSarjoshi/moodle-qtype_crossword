{"version":3,"file":"crossword_grid.min.js","sources":["../src/crossword_grid.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * CrosswordGrid class handle every function relative to grid.\r\n *\r\n * @module qtype_crossword/crossword_grid\r\n * @copyright 2022 The Open University\r\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport {CrosswordQuestion} from 'qtype_crossword/crossword_question';\r\nimport {CrosswordClue} from './crossword_clue';\r\n\r\nexport class CrosswordGrid extends CrosswordQuestion {\r\n\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @param {Object} options The settings for crossword.\r\n     */\r\n    constructor(options) {\r\n        super(options);\r\n    }\r\n\r\n    /**\r\n     * Build the background table.\r\n     */\r\n    buildBackgroundTable() {\r\n        let {colsNum, rowsNum, previewSetting} = this.options;\r\n        let style = previewSetting;\r\n\r\n        // Create table element.\r\n        const tableEl = document.createElement('table');\r\n\r\n        // Preview mode will add one more columns and row to add the coordinate helper.\r\n        colsNum++;\r\n        rowsNum++;\r\n\r\n        tableEl.className = 'crossword-grid';\r\n        // Set the background color.\r\n        tableEl.style.backgroundColor = style.backgroundColor;\r\n\r\n        for (let i = 0; i < rowsNum; i++) {\r\n            const rowEl = document.createElement('tr');\r\n            rowEl.className = 'grid-row';\r\n            for (let j = 0; j < colsNum; j++) {\r\n                // Create square.\r\n                let squareEl = document.createElement('td');\r\n                squareEl.className = 'grid-square';\r\n                squareEl.style.borderColor = style.borderColor;\r\n                squareEl.style.color = style.color;\r\n\r\n                if (i === 0 && j === 0) {\r\n                    squareEl.classList.add('cell-white');\r\n                }\r\n\r\n                // Adding alphanumeric.\r\n                if (i === 0 && j !== 0) {\r\n                    squareEl.innerText = this.getColumnLabel(j - 1);\r\n                    squareEl.classList.add('square-indicate-horizontal');\r\n                }\r\n                if (i !== 0 && j === 0) {\r\n                    squareEl.innerText = i;\r\n                    squareEl.classList.add('square-indicate-vertical');\r\n                }\r\n                rowEl.append(squareEl);\r\n            }\r\n            tableEl.append(rowEl);\r\n        }\r\n        this.tableEl = tableEl;\r\n        this.options.crosswordEl.innerHTML = tableEl.outerHTML;\r\n    }\r\n\r\n    /**\r\n     * Add each cell into table.\r\n     */\r\n    addCell() {\r\n        let {words, previewSetting, rowsNum, colsNum} = this.options;\r\n        const orientationMarks = ['→', '↓'];\r\n        // Don't draw empty words.\r\n        if (words.length === 0) {\r\n            return;\r\n        }\r\n        for (let i = 0; i < words.length; i++) {\r\n            const answer = words[i].answer.trim().replace(/-|\\s/g, '');\r\n            let row = words[i].startrow + 1;\r\n            let column = words[i].startcolumn + 1;\r\n            let answerLength = answer.length;\r\n            let realLength = answerLength + words[i].startcolumn;\r\n            let allowLength = parseInt(colsNum);\r\n            // Add more columns and row for preview.\r\n            row++;\r\n            column++;\r\n\r\n            if (words[i].orientation) {\r\n                realLength = answerLength + words[i].startrow;\r\n                allowLength = parseInt(rowsNum);\r\n            }\r\n\r\n            for (let j = 0; j < answer.length; j++) {\r\n                const number = i + 1;\r\n                let isInvalidLetter = false;\r\n                const squareEl = document.querySelector('.grid-row:nth-child(' + row + ') .grid-square:nth-child(' + column + ')');\r\n                if (!squareEl) {\r\n                    continue;\r\n                }\r\n\r\n                // Paint white background.\r\n                squareEl.classList.add('background-white');\r\n\r\n                if (j === 0) {\r\n                    const labelEl = squareEl.querySelector('.word-label');\r\n                    const labelText = 'W' + (words[i]?.no ?? number) + (orientationMarks[words[i].orientation]);\r\n                    if (!labelEl) {\r\n                        let spanEl = document.createElement('span');\r\n                        spanEl.className = 'word-label text-left';\r\n                        spanEl.innerText = labelText;\r\n                        squareEl.append(spanEl);\r\n                    } else {\r\n                        let label = labelEl.innerText;\r\n                        isInvalidLetter = label.includes(orientationMarks[words[i].orientation]);\r\n                        label += ', ' + labelText;\r\n                        labelEl.innerText = label;\r\n                    }\r\n                }\r\n                const letter = answer[j].toUpperCase().trim() ?? '';\r\n                const contentEl = squareEl.querySelector('span.word-content');\r\n                if (!isInvalidLetter) {\r\n                    isInvalidLetter = this.isContainSpecialCharacters(letter);\r\n                }\r\n                if (!contentEl) {\r\n                    let spanEl = document.createElement('span');\r\n                    spanEl.className = 'word-content';\r\n                    spanEl.innerText = letter;\r\n                    squareEl.append(spanEl);\r\n                } else {\r\n                    let text = '';\r\n                    const innerText = contentEl.innerText;\r\n                    if (innerText.search(letter) < 0) {\r\n                        isInvalidLetter = true;\r\n                        text = innerText + ' | ' + letter;\r\n                        contentEl.innerText = text;\r\n                    }\r\n                }\r\n\r\n                if (realLength > allowLength || isInvalidLetter) {\r\n                    squareEl.style.backgroundColor = previewSetting.conflictColor;\r\n                }\r\n\r\n                if (words[i].orientation) {\r\n                    row++;\r\n                } else {\r\n                    column++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Show the crossword preview.\r\n     */\r\n    previewCrossword() {\r\n        // Build the background table.\r\n        this.buildBackgroundTable();\r\n        // Fill the cell into the table.\r\n        this.addCell();\r\n    }\r\n\r\n    /**\r\n     * Build crossword for attempt.\r\n     */\r\n    buildCrossword() {\r\n        const options = this.options;\r\n        // Setup size of crossword.\r\n        this.options = {...options, width: options.colsNum * 31, height: options.rowsNum * 31};\r\n        // Set up for clue input: maxlength, aria-label.\r\n        const crosswordClue = new CrosswordClue(this.options);\r\n        crosswordClue.setUpClue();\r\n        // Draw crossword by SVG to support high contrast mode.\r\n        this.drawCrosswordSVG();\r\n        // Sync data between clue section and crossword cell.\r\n        this.syncDataForInit();\r\n        // Add event when resized screen.\r\n        this.addEventResizeScreen();\r\n    }\r\n\r\n    /**\r\n     * Draw crossword by SVG element.\r\n     */\r\n    drawCrosswordSVG() {\r\n        const options = this.options;\r\n        const crosswordEl = this.options.crosswordEl;\r\n\r\n        if (!crosswordEl) {\r\n            return;\r\n        }\r\n\r\n        // Create background.\r\n        let svg = this.createElementNSFrom(\r\n            'svg',\r\n            {\r\n                'class': 'crossword-grid',\r\n                viewBox: `0 0 ${options.width} ${options.height}`\r\n            }\r\n        );\r\n\r\n        // Create black background.\r\n        const rectEl = this.createElementNSFrom(\r\n            'rect',\r\n            {\r\n                'class': 'crossword-grid-background',\r\n                x: 0,\r\n                y: 0,\r\n                width: options.width,\r\n                height: options.height\r\n            }\r\n        );\r\n        svg.append(rectEl);\r\n\r\n        // Create svg body.\r\n        svg = this.createCrosswordBody(svg);\r\n\r\n        // Set size for crossword.\r\n        svg = this.setSizeForCrossword(svg);\r\n\r\n        // Add horizontal and vertical line.\r\n        svg = this.setBorder(svg);\r\n        // Create an input, by default, it will be hidden.\r\n        const inputContainEl = this.createElementFrom(\r\n            'div',\r\n            {\r\n                'class': 'crossword-hidden-input-wrapper'\r\n            }\r\n        );\r\n        const inputEl = this.createElementFrom(\r\n            'input',\r\n            {\r\n                type: 'text',\r\n                'class': 'crossword-hidden-input',\r\n                maxlength: 1,\r\n                autocomplete: 'off',\r\n                spellcheck: false,\r\n                autocorrect: 'off'\r\n            }\r\n        );\r\n        // Add event for word input.\r\n        this.addEventForWordInput(inputEl);\r\n        inputContainEl.append(inputEl);\r\n\r\n        if (options.colsNum >= 15) {\r\n            svg.classList.add('adjust-small-crossword');\r\n        }\r\n\r\n        if (options.colsNum >= 20) {\r\n            svg.classList.add('adjust-crossword');\r\n        }\r\n        crosswordEl.append(svg, inputContainEl);\r\n    }\r\n\r\n    /**\r\n     * Creates an element with the specified namespace URI and qualified name.\r\n     *\r\n     * @param {String} type\r\n     * @param {Object} attributes\r\n     *\r\n     * @return {Element} The return element.\r\n     */\r\n    createElementNSFrom(type, attributes = {}) {\r\n        const element = document.createElementNS('http://www.w3.org/2000/svg', type);\r\n        for (let key in attributes) {\r\n            element.setAttributeNS(null, key, attributes[key]);\r\n        }\r\n        return element;\r\n    }\r\n\r\n    /**\r\n     * Create element with attributes.\r\n     *\r\n     * @param {String} type\r\n     * @param {Object} attributes The attribute list.\r\n     * @return {Element} The return element.\r\n     */\r\n    createElementFrom(type, attributes = {}) {\r\n        const element = document.createElement(type);\r\n        for (let key in attributes) {\r\n            element.setAttribute(key, attributes[key]);\r\n        }\r\n        return element;\r\n    }\r\n\r\n    /**\r\n     * Calculate position and add cell into the crossword.\r\n     *\r\n     * @param {Element} svg  The svg element.\r\n     * @return {Element} The svg element.\r\n     */\r\n    createCrosswordBody(svg) {\r\n        const {words, cellWidth, cellHeight} = this.options;\r\n        let count = 0;\r\n        for (let i in words) {\r\n            const word = words[i];\r\n            const ignoreList = this.getIgnoreIndexByAnswerNumber(word.number);\r\n            for (let key = 0; key < word.length - ignoreList.length; key++) {\r\n                // Prepare attributes for g.\r\n                const customAttribute = {\r\n                    'data-startrow': word.startRow,\r\n                    'data-startcolumn': word.startColumn,\r\n                    'data-letterindex': key,\r\n                    'data-word': '(' + word.number + ')',\r\n                    'data-code': 'A' + count\r\n                };\r\n                // Calculate the letter position.\r\n                const position = this.calculatePosition(word, parseInt(key));\r\n                // Create rect element with these position.\r\n                const rectEl = this.createElementNSFrom(\r\n                    'rect',\r\n                    {\r\n                        ...position,\r\n                        width: cellWidth,\r\n                        height: cellHeight,\r\n                        'class': 'crossword-cell'\r\n                    }\r\n                );\r\n                // Create g element with the attributes.\r\n                let g = this.createElementNSFrom('g', {...customAttribute});\r\n                // Get exist ting rect element.\r\n                const existingRectElement = svg.querySelector(`rect.crossword-cell[x='${position.x}'][y='${position.y}']`);\r\n                // Create text element to hold the letter.\r\n                const textEl = this.createElementNSFrom(\r\n                    'text',\r\n                    {\r\n                        'class': 'crossword-cell-text',\r\n                        x: position.x + cellWidth / 2,\r\n                        y: position.y + cellHeight / 2 + 1,\r\n                        'text-anchor': 'middle',\r\n                        'alignment-baseline': 'middle',\r\n                    }\r\n                );\r\n                // Check if cell is not drawn.\r\n                if (!existingRectElement) {\r\n                    // Create cell.\r\n                    g.append(rectEl);\r\n                    // If it's the first cell of word.\r\n                    // Draw word number.\r\n                    if (parseInt(key) === 0) {\r\n                        g = this.appendCellNumber(g, position, word.number);\r\n                    }\r\n                    g.append(textEl);\r\n                    // Add event for cell.\r\n                    this.addEventForG(g);\r\n                    count++;\r\n                    svg.append(g);\r\n                } else {\r\n                    let existingNumberElement = existingRectElement.closest('g').querySelector('text.crossword-cell-number');\r\n                    let currentWord = existingRectElement.closest('g').dataset.word;\r\n                    let g;\r\n                    existingRectElement.closest('g').dataset.word = currentWord + '(' + word.number + ')';\r\n                    if (parseInt(key) !== 0) {\r\n                        continue;\r\n                    }\r\n                    if (existingNumberElement) {\r\n                        // Append word number, if this cell is existed another one.\r\n                        existingNumberElement.append(', ' + word.number);\r\n                    } else {\r\n                        // Create new word number.\r\n                        g = existingRectElement.closest('g');\r\n                        this.appendCellNumber(g, position, word.number);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return svg;\r\n    }\r\n\r\n    /**\r\n     * Set horizontal and vertical line for grid.\r\n     *\r\n     * @param {Element} svg The svg element.\r\n     * @return {Element} The svg element after appended border.\r\n     */\r\n    setBorder(svg) {\r\n        const {colsNum, rowsNum, cellWidth, cellHeight, width, height} = this.options;\r\n\r\n        for (let i = 0; i <= rowsNum; i++) {\r\n            let strokeWidth = 1;\r\n            if (i === 0 || i === rowsNum) {\r\n                strokeWidth = 2;\r\n            }\r\n            const horizontalLine = this.createElementNSFrom('line', {\r\n                x1: 0,\r\n                y1: i * cellHeight,\r\n                x2: width,\r\n                y2: i * cellHeight,\r\n                stroke: '#000',\r\n                'stroke-width': strokeWidth,\r\n            });\r\n            svg.appendChild(horizontalLine);\r\n        }\r\n\r\n        for (let i = 0; i <= colsNum; i++) {\r\n            let strokeWidth = 1;\r\n            if (i === 0 || i === colsNum) {\r\n                strokeWidth = 2;\r\n            }\r\n            const verticalLine = this.createElementNSFrom('line', {\r\n                x1: i * cellWidth,\r\n                y1: 0,\r\n                x2: i * cellWidth,\r\n                y2: height,\r\n                stroke: '#000',\r\n                'stroke-width': strokeWidth,\r\n            });\r\n            svg.appendChild(verticalLine);\r\n        }\r\n\r\n        return svg;\r\n    }\r\n\r\n    /**\r\n     * Create word number for the cell.\r\n     *\r\n     * @param {Element} g The g element.\r\n     * @param {Object} position The coordinates of letter.\r\n     * @param {Number} wordNumber The word number.\r\n     *\r\n     * @return {Element} The g element.\r\n     */\r\n    appendCellNumber(g, position, wordNumber) {\r\n        // Update position.\r\n        const x = position.x + 2;\r\n        const y = position.y + 10;\r\n        let textNumber = this.createElementNSFrom(\r\n            'text',\r\n            {\r\n                x,\r\n                y,\r\n                'class': 'crossword-cell-number'\r\n            }\r\n        );\r\n        textNumber.append(wordNumber);\r\n        g.append(textNumber);\r\n        return g;\r\n    }\r\n\r\n    /**\r\n     * Add event to the g element.\r\n     *\r\n     * @param {Element} g The g element.\r\n     */\r\n    addEventForG(g) {\r\n        const {readonly} = this.options;\r\n        if (readonly) {\r\n            return;\r\n        }\r\n        // Handle event click.\r\n        g.addEventListener('click', (e) => {\r\n            const inputWrapperEl = this.options.crosswordEl.querySelector('.crossword-hidden-input-wrapper');\r\n            const inputEl = inputWrapperEl.querySelector('input');\r\n            let element = e.target;\r\n            // Make sure select g.\r\n            if (element.tagName !== 'g') {\r\n                element = element.closest('g');\r\n            }\r\n            this.handleWordSelect(element);\r\n            inputEl.dataset.code = element.dataset.code;\r\n            inputEl.value = '';\r\n            this.updatePositionForCellInput(element.querySelector('rect'));\r\n            inputEl.focus();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handle action when click on cell.\r\n     *\r\n     * @param {Element} gEl The g element.\r\n     */\r\n    handleWordSelect(gEl) {\r\n        const currentCell = gEl.dataset.code;\r\n        let words = gEl.dataset.word;\r\n        let focus = -1;\r\n        let {coordinates, wordNumber} = this.options;\r\n\r\n        // Detect word number.\r\n        words = words.match(/(\\d+)/g);\r\n\r\n        // Detect word number based on event click.\r\n        // The focus variable is the new word number.\r\n        if (currentCell === coordinates) {\r\n            const indexCell = words.indexOf(wordNumber);\r\n            if (words[indexCell + 1] !== undefined) {\r\n                focus = words[indexCell + 1];\r\n            } else {\r\n                focus = words[0];\r\n            }\r\n        } else {\r\n            // Update new coordinates.\r\n            this.options.coordinates = currentCell;\r\n            if (wordNumber < 0) {\r\n                this.options.wordNumber = words[0];\r\n            }\r\n            if (words.includes(wordNumber)) {\r\n                focus = wordNumber;\r\n            } else {\r\n                focus = words[0];\r\n            }\r\n        }\r\n        // Update word number.\r\n        this.options.wordNumber = focus;\r\n        const word = this.options.words.find(o => o.number === parseInt(focus));\r\n        if (!word) {\r\n            return;\r\n        }\r\n        // Sorting and Updating letter index.\r\n        this.updateLetterIndexForCells(word);\r\n        // Toggle highlight and focused.\r\n        this.toggleHighlight(word, gEl);\r\n        // Focus the clue.\r\n        this.focusClue();\r\n        // Update sticky clue for mobile version.\r\n        this.setStickyClue();\r\n    }\r\n\r\n    /**\r\n     * Set size and position for cell input.\r\n     *\r\n     * @param {Element} [rectEl=null] Rect element.\r\n     */\r\n    updatePositionForCellInput(rectEl = null) {\r\n        if (rectEl === null) {\r\n            rectEl = this.options.crosswordEl.querySelector('rect.crossword-cell-focussed');\r\n        }\r\n        if (rectEl) {\r\n            const rect = rectEl.getBoundingClientRect();\r\n            const parentEl = this.options.crosswordEl.querySelector('.crossword-grid').getBoundingClientRect();\r\n            const inputWrapperEl = this.options.crosswordEl.querySelector('.crossword-hidden-input-wrapper');\r\n            let top = rect.top - parentEl.top;\r\n            if (top < 1) {\r\n                top = 0;\r\n            }\r\n            inputWrapperEl.style.cssText = `\r\n                display: block; top: ${top + 2}px;\r\n                left: ${rect.left - parentEl.left + 2}px;\r\n                width: ${rect.width - 3}px;\r\n                height: ${rect.height - 3}px\r\n            `;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle insert text event (for keyboard and non-keyboard events).\r\n     *\r\n     * @param {Object} event Event data.\r\n     * @param {String} value the character we are inserted to the clue grid.\r\n     */\r\n    handleInsertTextEventForGridInput(event, value) {\r\n        const {wordNumber, words} = this.options;\r\n        const inputEl = event.target;\r\n        let code = inputEl.dataset.code;\r\n        const upperText = value.toUpperCase();\r\n        if (this.replaceText(value) === '') {\r\n            return;\r\n        }\r\n        // If a letter is entered using an IME keyboard, it may contain multiple characters.\r\n        // Therefore, we need to split it into an array and loop through it to handle each character.\r\n        let chars = upperText.split('');\r\n        let letterIndex;\r\n        const wordObj = words.find(word => word.number === parseInt(wordNumber));\r\n        for (let char of chars) {\r\n            // Find the text element in the g element based on the code.\r\n            const textEl = this.options.crosswordEl.querySelector(`g[data-code='${code}'] text.crossword-cell-text`);\r\n            if (!textEl || this.replaceText(char) === '') {\r\n                continue;\r\n            }\r\n            // Set character into text element in grid.\r\n            textEl.innerHTML = char;\r\n            if (!letterIndex) {\r\n                // Set the letter index based on the text element for the first time.\r\n                letterIndex = parseInt(textEl.closest('g').dataset.letterindex);\r\n            }\r\n            // When the answer contains special characters, the next `charIndex` will not be equal to `letterIndex + 1`.\r\n            // For example, if the answer is \"A-B-C\", when attempting to display the answer in the clue input,\r\n            // it will be shown as \"_ - _ - _\", the letter index will be 0(A), 1(-), 2(B), 3(-), 4(C),\r\n            // but in the grid, only three cells will be shown with letter indices:\r\n            // 0 (A), 2 (B), and 4 (C) (special characters are not counted).\r\n            // Therefore, when the user enters the cell for the first letter in the grid (letter index 0),\r\n            // the next cell will have a letter index of 2.\r\n            const [charIndex, nextCellEl] = this.findTheClosestCell(wordNumber, wordObj, letterIndex + 1);\r\n            // Assign a new letter to the clue input.\r\n            this.bindDataToClueInput(textEl.closest('g'), char);\r\n            if (!nextCellEl) {\r\n                return;\r\n            }\r\n            // Update code.\r\n            code = nextCellEl.dataset.code;\r\n            // Update `letterIndex`.\r\n            letterIndex = charIndex;\r\n            nextCellEl.dispatchEvent(new Event('click'));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add event to word input element.\r\n     *\r\n     * @param {Element} inputEl The input element.\r\n     */\r\n    addEventForWordInput(inputEl) {\r\n        const {readonly} = this.options;\r\n        if (readonly) {\r\n            return;\r\n        }\r\n\r\n        // Handle IME input.\r\n        inputEl.addEventListener('beforeinput', (e) => {\r\n            if (e.inputType === 'insertText' && e.data) {\r\n                this.handleInsertTextEventForGridInput(e, e.data);\r\n            }\r\n        });\r\n\r\n        inputEl.addEventListener('keypress', (e) => {\r\n            e.preventDefault();\r\n            // On mobile devices, the Backspace key may trigger the keypress event when the user uses Input Method Editor.\r\n            // Therefore, we need to prevent this behavior.\r\n            if (e.key === this.BACKSPACE) {\r\n                return false;\r\n            }\r\n            this.handleInsertTextEventForGridInput(e, e.key);\r\n            return true;\r\n        });\r\n\r\n        inputEl.addEventListener('compositionend', (evt) => {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n            const {wordNumber, words} = this.options;\r\n            const wordObj = words.find(word => word.number === parseInt(wordNumber));\r\n            let key = evt.data.toUpperCase();\r\n            const code = evt.target.dataset.code;\r\n            if (this.replaceText(key) === '') {\r\n                return false;\r\n            }\r\n            if (code) {\r\n                let chars = key.split('');\r\n                const gEl = this.options.crosswordEl.querySelector(`g[data-code='${code}']`);\r\n                if (!gEl) {\r\n                    return false;\r\n                }\r\n                let letterIndex = parseInt(gEl.dataset.letterindex);\r\n                for (let char of chars) {\r\n                    if (this.replaceText(char) === '') {\r\n                        continue;\r\n                    }\r\n                    // Retrieve the next valid cell and its corresponding character index.\r\n                    const [charIndex, cellEl] = this.findTheClosestCell(wordNumber, wordObj, letterIndex);\r\n                    // Interact with clue.\r\n                    if (cellEl) {\r\n                        letterIndex = charIndex;\r\n                        cellEl.querySelector('text.crossword-cell-text').innerHTML = char;\r\n                        this.bindDataToClueInput(cellEl, char);\r\n                        // Make sure not to click when a cell is already focused.\r\n                        if (!cellEl.querySelector('.crossword-cell-focussed')) {\r\n                            cellEl.dispatchEvent(new Event('click'));\r\n                        }\r\n                        // Increment to the next letter index.\r\n                        letterIndex++;\r\n                    }\r\n                }\r\n\r\n                const nextCellEl = this.findTheClosestCell(wordNumber, wordObj, letterIndex).pop() ?? null;\r\n                if (nextCellEl) {\r\n                    nextCellEl.dispatchEvent(new Event('click'));\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n\r\n        inputEl.addEventListener('keyup', (event) => {\r\n            event.preventDefault();\r\n            const {wordNumber, cellWidth, cellHeight, words} = this.options;\r\n            const {key, target} = event;\r\n            const code = target.dataset.code;\r\n            const gEl = this.options.crosswordEl.querySelector(`g[data-code='${code}']`);\r\n            const word = words.find(o => o.number === parseInt(wordNumber));\r\n            const letterIndex = this.findTheClosestCell(wordNumber, word,\r\n                parseInt(gEl.dataset.letterindex) - 1, false)[0];\r\n            const previousCell = this.options.crosswordEl.querySelector(\r\n                `g[data-word*='(${wordNumber})'][data-letterindex='${letterIndex}']`\r\n            );\r\n            const textEl = gEl.querySelector('text.crossword-cell-text');\r\n            let x = parseInt(gEl.querySelector('rect').getAttributeNS(null, 'x'));\r\n            let y = parseInt(gEl.querySelector('rect').getAttributeNS(null, 'y'));\r\n            if (key === this.DELETE || key === this.BACKSPACE) {\r\n                if (textEl.innerHTML === '') {\r\n                    if (previousCell) {\r\n                        previousCell.dispatchEvent(new Event('click'));\r\n                    }\r\n                } else {\r\n                    textEl.innerHTML = '';\r\n                    this.bindDataToClueInput(gEl, '_');\r\n                }\r\n            }\r\n            if ([this.ARROW_UP, this.ARROW_DOWN, this.ARROW_LEFT, this.ARROW_RIGHT].includes(key)) {\r\n                if (key === this.ARROW_UP) {\r\n                    y -= cellHeight;\r\n                }\r\n                if (key === this.ARROW_DOWN) {\r\n                    y += cellHeight;\r\n                }\r\n                if (key === this.ARROW_LEFT) {\r\n                    x -= cellWidth;\r\n                }\r\n                if (key === this.ARROW_RIGHT) {\r\n                    x += cellWidth;\r\n                }\r\n                const nextCell = this.options.crosswordEl.querySelector(`g rect[x='${x}'][y='${y}']`);\r\n                if (nextCell) {\r\n                    nextCell.closest('g').dispatchEvent(new Event('click'));\r\n                }\r\n            }\r\n        });\r\n\r\n        inputEl.addEventListener('click', (e) => {\r\n            const inputEl = e.target;\r\n            const code = inputEl.dataset.code;\r\n            const gEl = this.options.crosswordEl.querySelector(`g[data-code='${code}']`);\r\n            this.handleWordSelect(gEl);\r\n        });\r\n\r\n        inputEl.addEventListener('keydown', (e) => {\r\n            let {key} = e;\r\n            key = key.toLowerCase();\r\n            if (e.ctrlKey) {\r\n                if (\r\n                    key === this.Z_KEY ||\r\n                    key === this.A_KEY\r\n                ) {\r\n                    e.preventDefault();\r\n                }\r\n            }\r\n\r\n            if (e.key === this.ENTER) {\r\n                e.preventDefault();\r\n            }\r\n        });\r\n\r\n        inputEl.addEventListener('paste', (e) => {\r\n            e.preventDefault();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add event to resize the screen width.\r\n     */\r\n    addEventResizeScreen() {\r\n        window.addEventListener('resize', () => {\r\n            this.updatePositionForCellInput();\r\n        });\r\n    }\r\n}\r\n"],"names":["CrosswordGrid","CrosswordQuestion","constructor","options","buildBackgroundTable","colsNum","rowsNum","previewSetting","this","style","tableEl","document","createElement","className","backgroundColor","i","rowEl","j","squareEl","borderColor","color","classList","add","innerText","getColumnLabel","append","crosswordEl","innerHTML","outerHTML","addCell","words","orientationMarks","length","answer","trim","replace","row","startrow","column","startcolumn","answerLength","realLength","allowLength","parseInt","orientation","number","isInvalidLetter","querySelector","labelEl","labelText","_words$i","no","label","includes","spanEl","letter","toUpperCase","contentEl","isContainSpecialCharacters","text","search","conflictColor","previewCrossword","buildCrossword","width","height","CrosswordClue","setUpClue","drawCrosswordSVG","syncDataForInit","addEventResizeScreen","svg","createElementNSFrom","viewBox","rectEl","x","y","createCrosswordBody","setSizeForCrossword","setBorder","inputContainEl","createElementFrom","inputEl","type","maxlength","autocomplete","spellcheck","autocorrect","addEventForWordInput","attributes","element","createElementNS","key","setAttributeNS","setAttribute","cellWidth","cellHeight","count","word","ignoreList","getIgnoreIndexByAnswerNumber","customAttribute","startRow","startColumn","position","calculatePosition","g","existingRectElement","textEl","existingNumberElement","closest","currentWord","dataset","appendCellNumber","addEventForG","strokeWidth","horizontalLine","x1","y1","x2","y2","stroke","appendChild","verticalLine","wordNumber","textNumber","readonly","addEventListener","e","target","tagName","handleWordSelect","code","value","updatePositionForCellInput","focus","gEl","currentCell","coordinates","match","indexCell","indexOf","undefined","find","o","updateLetterIndexForCells","toggleHighlight","focusClue","setStickyClue","rect","getBoundingClientRect","parentEl","inputWrapperEl","top","cssText","left","handleInsertTextEventForGridInput","event","upperText","replaceText","letterIndex","chars","split","wordObj","char","letterindex","charIndex","nextCellEl","findTheClosestCell","bindDataToClueInput","dispatchEvent","Event","inputType","data","preventDefault","BACKSPACE","evt","stopPropagation","cellEl","pop","previousCell","getAttributeNS","DELETE","ARROW_UP","ARROW_DOWN","ARROW_LEFT","ARROW_RIGHT","nextCell","toLowerCase","ctrlKey","Z_KEY","A_KEY","ENTER","window"],"mappings":"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"}